本文记录了我使用 AI 编码工具的一些心得体会，希望对你也有帮助，如果你看完有任何想法，也欢迎和我沟通。

# AI 工具

我目前在用的有三款：

- [gemini cli](https://github.com/google-gemini/gemini-cli)
- [iflow cli](https://github.com/iflow-ai/iflow-cli)
- [claude code](https://github.com/anthropics/claude-code) 国内使用[参考教程](https://www.cnblogs.com/javastack/p/19217578)，使用的是 doubao-seed-code 模型

我偏向在终端中使用 ai 工具，在终端看着它自己运行并解决问题体验挺好的。对于一些简单的问题，比如：`pgrep` 的用法？我会倾向于使用网页版，毕竟网页版的页面进入很快。

各个工具的官方文档其实也详细介绍了各种使用技巧，值得学习，比如：

- [claude code 常用工作流程](https://code.claude.com/docs/en/common-workflows)

# 氛围编程

对于一些小工具，比较偏向于使用这种方式，把 AI 写的代码当作一个黑盒，从不打开看，让 AI 自己去编写、验证、修改，我看着哪里不好，就给出修改意见，哪怕这个意见比较模糊，最后直到我满意为止。我不会去看甚至理解具体的实现细节，一方面也是怕我自己强迫症犯了忍不住去改。这里可以参考 Andrej Karpathy 在推特上创造 “vibe coding”（氛围编码）一词时提到的内容：

> 我发明了一种新的编程方式，我称之为 “灵感编程”。在这种编程方式中，你完全沉浸在灵感之中，拥抱指数级增长，甚至忘记代码的存在。这之所以成为可能，是因为 LLM（例如带有 Sonnet 的 Cursor Composer）变得越来越强大。而且，我直接用 SuperWhisper 和 Composer 对话，几乎不用碰键盘。我会提出一些最愚蠢的要求，比如 “将侧边栏的内边距减少一半”，因为我懒得去找。我总是 “全部接受”，不再看差异对比。遇到错误信息时，我直接复制粘贴进去，不加任何注释，通常这样就能解决问题。代码的复杂程度远远超出了我的理解范围，我得花很长时间才能真正理解它。有时 LLM 也无法修复 bug，所以我只能想办法绕过它，或者提出一些随机的修改，直到问题消失。对于周末的临时项目来说，这种方式还算可以接受，而且也挺有意思的。我正在构建一个项目或 Web 应用程序，但这实际上并不是编码 —— 我只是查看一些东西，说一些东西，运行一些东西，复制粘贴一些东西，而且它大部分都能正常工作。

这样的方式可以快速创建一些短期可用的产品，如果要长期维护，并在此基础上增加新功能，就不太适用了。

# 规范驱动开发

大型应用开发时我比较偏向使用这种方式，可以减少 AI 的理解偏差，也可以减少团队成员的理解偏差。

据我所知目前的几种规范落地工具：

- [openspec](https://github.com/Fission-AI/OpenSpec)
- [github/spec-kit: 💫 Toolkit to help you get started with Spec-Driven Development](https://github.com/github/spec-kit)

我目前仅仅使用过 openspec，用下来发现这仍然时比较考验模型本身能力的，此外，虽然 openspec 本身的命令有标准的提示词，但我们仍然可以对其修改，以符合自己的项目实际情况，比如在生成提案时，需要明确的给出表结构语句、涉及的 sql 等，可以减少应用提案时的歧义。

使用 openspec 时，每次的需求应该尽可能明确，且规模范围小，避免让 AI 一次性处理太多内容，容易产生幻觉，或造成上下文过长。人在面对太多需求时也难免会手忙脚乱，更何况 AI 了。如果需求比较大，可以适当拆分为几个小的需求，并依次提供给 AI。

在第一次生成提案时，可能会反复的和 AI 沟通，确保生成的结果是准确且符合预期的，那么在这之后，可以将沟通的内容总结出来，改进生成提案命令所使用的提示词。

另外最近看到一个只包含规范的开源项目：[whenwords](https://github.com/dbreunig/whenwords)，作者本质上仅仅开源了规范，而我们可以根据这份规范使用任意 AI 模型生成想要的代码语言。背景和相关思考可以参见：[一个无需代码的软件库](https://www.dbreunig.com/2026/01/08/a-software-library-with-no-code.html)。我觉得这是一个很有意思的项目，可以让我们窥见一些未来项目开发的可能性，当然作者也提到了这种方式需要面临的挑战，比如：

- 无法应用复杂的测试场景
- 几乎不能重现 BUG
- 迭代更新

考虑到以上种种问题，我觉得目前规范驱动开发算是一种比较合适的使用 AI 的方式，但在构建和迭代大型项目上还需要更多的实践。

# BMAD-METHOD

本质上，这是一个让 AI 扮演产品经理、架构师、开发人员、测试人员、UX 设计师等各种角色，然后组建为一个专业团队供你调用。其安装和使用可以参考：

- [bmad-code-org/BMAD-METHOD: Breakthrough Method for Agile Ai Driven Development](https://github.com/bmad-code-org/BMAD-METHOD)

在 iflow 中使用示例：

- [BMAD-METHOD：通用 AI 代理框架的工作流程与原理解析](https://zhuanlan.zhihu.com/p/1963978717362619872)

这是一种值得学习和实践的方式，我在实际使用中还没怎么用到，但以后一定会尝试。除此之外，可以考虑增加一些角色，如果安全评审，代码规范检查等，用于 CI/CD 流程。

# 用 git worktree 让工具并行

这里引用 claude code 官方文档上的描述：

- 每个工作树都有其独立的文件状态，这使其非常适合并行 Claude Code 会话
- 在一个工作树中所做的更改不会影响其他工作树，从而防止 Claude 实例之间相互干扰
- 所有工作树共享相同的 Git 历史记录和远程连接
- 对于长时间运行的任务，您可以让 Claude 在一个工作树中工作，而您则在另一个工作树中继续开发
- 使用描述性的目录名称，以便轻松识别每个工作树所对应的任务
- 请记住，在每个新的工作树中，都要根据项目配置初始化开发环境

如果你需要让 AI 加大马力干活，可以试试这种方式。

# 重视测试

测试可以让 AI 快速的验证自己写的代码有无问题，如果你在写开始项目之前已经有非常完善的测试，那么完全可以放心的让 ai 遵循测试驱动开发的流程来工作，只要让 AI 别修改测试文件就行，如果它认为确实有必要修改，那么也要先征得你的同意。

另一方面，也可以为 AI 提供完备的测试规则，让它根据规则生成测试代码，然后验证，改进业务代码。

# 提示词很重要

我发现的一些值得参考的内容：

- [分享个人在用的 IFLOW 编程全局提示词 - iFlow CLI / 实践探索 - 心流 AI 交流社区](https://vibex.iflow.cn/t/topic/257) 适用于 iflow，同时也可以改进以适配 gemini，claude 等
- [awesome-cursor-rules-mdc/rules-mdc/python.mdc at main · sanjeed5/awesome-cursor-rules-mdc](https://github.com/sanjeed5/awesome-cursor-rules-mdc/blob/main/rules-mdc/python.mdc) 适用于 cursor，但对于其他 AI 工具仍有参考价值

# 纸上得来终觉浅，觉知此事要躬行

虽然 AI 生成代码的速度之快，已经让我觉得写代码都没有必要，但我仍然乐意花一些时间，自己手写一些代码，这可以让我对代码的运行和使用有更深的理解。

传统的书籍仍然值得我去学习，虽然它们大都已经被 AI 吸收，但只有在我自己了解之后，才能知道在何时，何处恰当的运用相关的知识。这些仍然是 AI 所不能替代的，毕竟 AI 不能替我做决策，正如 AI 不能替我背锅一样。