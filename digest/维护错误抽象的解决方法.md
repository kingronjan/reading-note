*From: [The Wrong Abstraction — Sandi Metz](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)*

核心思想是“最快的方法是倒退”。具体步骤如下：

   1. 重新引入重复代码：将抽象出的代码重新内联到每一个调用者中。
   2. 筛选代码：在每个调用者内部，根据传入的参数，确定并保留该调用者实际执行所需的内联代码子集。
   3. 删除冗余代码：删除特定调用者不需要的代码部分。

  这样做可以消除错误的抽象和条件判断，使每个调用者只包含其所需的代码。完成此过程后，可以重新识别重复代码并提取正确的抽象。

 When dealing with the wrong abstraction, *the fastest way forward is back*. Do the following:

1. Re-introduce duplication by inlining the abstracted code back into every caller.
2. Within each caller, use the parameters being passed to determine the subset of the inlined code that this specific caller executes.
3. Delete the bits that aren't needed for this particular caller.

This removes both the abstraction *and* the conditionals, and reduces each caller to only the code it needs. When you rewind decisions in this way, it's common to find that although each caller ostensibly invoked a shared abstraction, the code they were running was fairly unique. Once you completely remove the old abstraction you can start anew, re-isolating duplication and re-extracting abstractions.

