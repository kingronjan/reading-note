---
categories:
- reading
date: 2025-07-22 17:56 +0800
id: 767c2e37-1cab-4e28-9332-8c00e884aba8
layout: post
tags:
- reading
title: '#14 | Mastering Postgres Replication Slots'
---

### Python

##### [Application Logging in Python: Recipes for Observability · Dash0](https://www.dash0.com/guides/logging-in-python)

This guide will show you how to create **structured logging records**, like those in **JSON** format, and explain why this is crucial for improving your application's **observability**.



The following example particularly struck me, demonstrating the ability to **dynamically enrich logs with contextual information**:



```python
import logging
import socket
import os
import contextvars
from contextlib import contextmanager

_log_context = contextvars.ContextVar("log_context", default={})


class ContextFilter(logging.Filter):
    def __init__(self, name=""):
        super().__init__(name)
        self.hostname = socket.gethostname()
        self.process_id = os.getpid()

    def filter(self, record):
        # global context vars
        record.hostname = self.hostname
        record.process_id = self.process_id
		
        # specify contxt vars
        context = _log_context.get()
        for key, value in context.items():
            setattr(record, key, value)

        return True


@contextmanager
def add_to_log_context(**kwargs):
    current_context = _log_context.get()
    new_context = {**current_context, **kwargs}

    # Set the new context and get the token for restoration
    token = _log_context.set(new_context)

    try:
        yield
    finally:
        _log_context.reset(token)
        
        
# and usages:

...


@app.middleware("http")
async def add_request_context(request: Request, call_next):
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))

    with add_to_log_context(request_id=request_id):
        response = await call_next(request)
        return response

```



##### [Developing a Real-time Dashboard with FastAPI, MongoDB, and WebSockets | TestDriven.io](https://testdriven.io/blog/fastapi-mongo-websockets/)

This tutorial looks at how to develop a real-time order dashboard with FastAPI and MongoDB (along with HTML, CSS, and JavaScript). We'll use MongoDB [Change Streams](https://www.mongodb.com/docs/manual/changestreams/) and [WebSockets](https://en.wikipedia.org/wiki/WebSocket) to stream live data updates from the FastAPI backend to the frontend.



##### [Making a Simple HTTP Server with Asyncio Protocols](https://jacobpadilla.com/articles/asyncio-protocols)

That being said, if you just need a dead-simple HTTP server, it’s kind of interesting to see how much faster you can make things by building your own HTTP server



### Dev

##### [Mastering Postgres Replication Slots: Preventing WAL Bloat and Other Production Issues - Gunnar Morling](https://www.morling.dev/blog/mastering-postgres-replication-slots/)

This article, by Gunnar Morling, provides best practices for configuring and managing Postgres replication slots to avoid problems like Write-Ahead Log (WAL) bloat in Change Data Capture (CDC) pipelines.

Key takeaways include:

- **`pgoutput` Plugin:** The article recommends using the `pgoutput` logical decoding plugin for its efficiency, binary format, and granular control over replicated data.
- **Maximum Replication Slot Size:** It's crucial to set a maximum replication slot size with `max_slot_wal_keep_size` (Postgres 13+) to prevent uncontrolled WAL growth and disk space issues.
- **Heartbeats:** To prevent WAL retention in idle databases, the article suggests enabling heartbeats, especially using `pg_logical_emit_message()` (Postgres 14+) to advance replication slots.
- **Optimized Streaming:** Using table-level publications and column/row filters (Postgres 15+) can optimize resource usage and reduce egress costs by selectively streaming data changes.
- **Failover Support:** The article discusses the improved failover support for replication slots in Postgres 16 (manual synchronization) and Postgres 17 (full automatic failover), ensuring continuous data consumption after a primary server failure.
- **Monitoring:** Comprehensive monitoring of WAL size, retained WAL per slot, remaining WAL space, and slot status is essential for operational stability.



##### [Real-time Data Replication with Debezium and Python](https://debezium.io/blog/2025/02/01/real-time-data-replication-with-debezium-and-python/)

This article discusses real-time data replication using Debezium and Python, specifically demonstrating a Change Data Capture (CDC) pipeline. It highlights that while Debezium is Java-based, the data engineering community increasingly uses Python, and introduces `pydbzengine` as a way to bridge this gap.

The core of the article explains how to capture change data from a PostgreSQL database and load it into a DuckDB database using the Data Load Tool (DLT), all within a Python environment. It breaks down the key components: Debezium for capturing change events, `pydbzengine` for interacting with Debezium in Python, DLT for loading data, DuckDB as an analytical database, and Testcontainers for managing the PostgreSQL database during testing. The article provides a code breakdown, detailing the setup of the environment, configuration of Debezium properties (including unwrapping messages), implementation of a `DltChangeHandler` to connect Debezium and DLT, and the orchestration of the entire process in a `main` function. Finally, it shows how to query the loaded data in DuckDB. The author emphasizes that this combination offers a robust and simple solution for real-time data synchronization and analysis, making it easy to integrate Debezium into existing Python workflows



##### [Improve Your Visual Studio Code's Look with Custom Fonts - DEV Community](https://dev.to/kunaltanwar/how-to-change-vs-code-ui-font-in-windows-5e2e)

This article from the DEV Community explains how to change the UI font in Visual Studio Code on Windows. The author describes modifying the `workbench.desktop.main.css` file to change the general UI font by replacing "Segoe UI" with a custom font like "Inter."

For other UI elements such as the Context Menu and Search Bar, the `workbench.desktop.main.js` file needs to be edited. Markdown previews require modification of the `markdown.css` file. A minor inconvenience of this method is an "[Unsupported]" warning that appears on startup, which can be dismissed. The main drawback is that these changes must be reapplied after every VS Code update.

You can simply search `Segoe WPC` and replace with a custom font