---
categories:
- reading
date: 2025-08-07 15:58 +0800
id: 87073772-2cde-45f3-b1b8-abe04e9b9559
layout: post
tags:
- reading
title: '#15'
---

### Python

##### [Stop Using Django's squashmigrations: There's a Better Way | Johnny Metz](https://johnnymetz.com/posts/squash-django-migrations/)

一种清理 django migrations 文件的方法，比官方的 `squashmigrations` 命令更快捷有效，具体操作如下：

1. 删除所有迁移文件（如果有 [data migrations](https://docs.djangoproject.com/en/5.2/topics/migrations/#data-migrations)，需要保留）

2. 重新使用 `makemigrations`  命令生成新的迁移文件 `0001_initial.py` 

3. 将 [data migrations](https://docs.djangoproject.com/en/5.2/topics/migrations/#data-migrations) 文件集中到一个或多个文件

4. 重置部署环境的迁移文件应用记录

   ```python
   from django.core.management import call_command
   from django.db import connection
   
   with connection.cursor() as cursor:
       cursor.execute("TRUNCATE TABLE django_migrations")
   
   call_command("migrate", fake=True)
   ```

当然，上面的操作需要确保当前的迁移记录在所属环境都已经全部被应用了，否则可能会出现丢失。



##### [TIL: Exception.add_note](https://daniel.feldroy.com/posts/til-2025-05-exception-add_note)

Python 3.11 给异常新加了一个方法 `add_note`，顾名思义，就是给异常加日志，在看到异常时也可以看到通过 `add_note` 添加的内容，比如：

```python
try:
    1/0
except ZeroDivisionError as e:
    e.add_note("This is a note about the error")
    e.add_note("This is another note")
    e.add_note("All notes must be strings")
    raise 
```

结果如下：

```
=========================================================
ZeroDivisionError       Traceback (most recent call last)
Cell In[1], line 2
      1 try:
====> 2     1/0
      3 except ZeroDivisionError as e:
      4     e.add_note("This is a note about the error")

ZeroDivisionError: division by zero
This is a note about the error
This is another note
All notes must be strings
```

该方法属于 `BaseException`，基于本适用于所有的异常了。如果实现自己的异常只是为了定制异常信息，可以考虑直接使用该方法。



##### [Create space-saving clones on macOS with Python – alexwlchan](https://alexwlchan.net/2025/cloning-with-python/)

学到了如何使用 python 的 ctypes 调用系统函数:

```python
import ctypes
import os

# Load the libSystem library
libSystem = ctypes.CDLL("libSystem.B.dylib", use_errno=True)

# Tell ctypes about the function signature
# int clonefile(const char * src, const char * dst, int flags);
clonefile = libSystem.clonefile
clonefile.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]
clonefile.restype = ctypes.c_int

# Source and destination files
src = b"1GB.bin"
dst = b"clone.bin"

# clonefile(2) supports several options related to symlinks and
# ownership information, but for this example we'll just use
# the default behaviour
flags = 0

# Actually call the clonefile() function
if clonefile(src, dst, flags) != 0:
    errno = ctypes.get_errno()
    raise OSError(errno, os.strerror(errno))
    
print(f"clonefile succeeded: {src} ~> {dst}")
```

至于怎么知道是 `libSystem.B.dylib`, 作者也讲了:

```console
$ otool -L /bin/cp
/bin/cp:
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1351.0.0)
```





### Tools

##### [natibek/erys: erys: Terminal Interface for Jupyter Notebooks.](https://github.com/natibek/erys)

可以在终端使用 jupyter notebook